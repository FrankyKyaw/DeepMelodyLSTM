from tensorflow.keras.models import Model
from train_model import generate_model
import numpy as np
from music21 import note, chord, instrument, stream

sequence_length = 50
n_vocab = 7019
model = generate_model(sequence_length, n_vocab)
 
model.load_weights('drive/My Drive/Datasets/weights/lakhDataset/weights-improvement-200-6.0951-bigger.hdf5')

temperature_model = Model(inputs=model.input, outputs=model.layers[-2].output)

def softmax(x):
    return np.exp(x) / np.sum(np.exp(x), axis=0)

def temperature_sampling(predictions, temperature=1.0):
    scaled = predictions / temperature
    probabilities = softmax(scaled)
    choice = np.random.choice(len(probabilities), p=probabilities) # choose according to probability
    return choice

def predict_notes(weight_file_path, sequence_length, n_vocab, pitchnames, network_input, temperature=1.0, n_notes=300):
    """
    Generates a list of notes of given length given the model weights

    Args:
        weight_file_path (_type_): _description_
        sequence_length (_type_): _description_
        n_vocab (_type_): _description_
        pitchnames (_type_): _description_
        network_input (_type_): _description_
        temperature (float, optional): _description_. Defaults to 1.0.
        n_notes (int, optional): _description_. Defaults to 300.

    Returns:
        list: A list of notes 
    """
    model = generate_model(sequence_length, n_vocab)
    model.load_weights(weight_file_path)

    temperature_model = Model(inputs=model.input, outputs=model.layers[-2].output)
    int_to_note = dict((number, note) for number, note in enumerate(pitchnames))
    pattern = network_input[-1]
    prediction_output = []
    temperature = 0.5

    for _ in range(n_notes):
        prediction_input = np.reshape(pattern, (1, len(pattern)))
        prediction = temperature_model.predict(prediction_input, verbose=0)
        index = temperature_sampling(prediction[0], temperature)
        result = int_to_note[index]
        prediction_output.append(result)

        pattern = np.append(pattern, index)
        pattern = pattern[1:len(pattern)]
    return prediction_output

def generate_notes(prediction_output, filepath='output.mid'):
    """
    Generates a MIDI file in the file path from a list of notes

    Args:
        prediction_output (list): _description_
        filepath (str, optional): _description_. Defaults to 'output.mid'.
    """
    offset = 0
    output_notes = []
    # create note and chord objects based on the values generated by the model
    for pattern in prediction_output:
        # pattern is a chord
        try:
            if ('.' in pattern):
                notes_in_chord = pattern.split('.')
                notes = []
                for current_note in notes_in_chord:
                    new_note = note.Note(int(current_note))
                    new_note.storedInstrument = instrument.Piano()
                    notes.append(new_note)
                new_chord = chord.Chord(notes)
                new_chord.offset = offset
                output_notes.append(new_chord)
            # pattern is a note
            else:
                new_note = note.Note(pattern)
                new_note.offset = offset
                new_note.storedInstrument = instrument.Piano()
                output_notes.append(new_note)
        except Exception as e:
            print(f"Error processing {pattern}: {e}")
        # increase offset each iteration so that notes do not stack
        offset += 0.5
    midi_stream = stream.Stream(output_notes)
    midi_stream.write('midi', fp=filepath)