from tensorflow.keras.models import load_model
from train_model import generate_model
import numpy as np
from music21 import note, chord, instrument, stream
import json

def softmax(x):
    return np.exp(x) / np.sum(np.exp(x), axis=0)

def temperature_sampling(predictions, temperature=1.0):
    scaled = np.log(predictions) / temperature
    probabilities = softmax(scaled)
    choice = np.random.choice(len(probabilities), p=probabilities) # choose according to probability
    return choice

def predict_notes(starting_seed, sequence_length, mapping_path="mappings.json", model_path="model.h5", temperature=1.0, n_notes=300):
    """ 
    Example starting_seed would be ["60", "_", "_", "_", "80", "_", "_", "_", "100", "_", "_", "_"]
    """
    model = load_model(model_path)
    with open(mapping_path, "r") as fp:
        mappings = json.load(fp)


    starting_sequence = [mappings[symbol] for symbol in starting_seed]

    prediction_output = []
    reverse_mappings = {value: key for key, value in mappings.items()}
    
    for _ in range(n_notes):
        starting_sequence = starting_sequence[-sequence_length:]
        prediction_input = np.reshape(starting_sequence, (1, len(starting_sequence)))
        prediction = model.predict(prediction_input, verbose=0)
        index = temperature_sampling(prediction[0], temperature)
        result = reverse_mappings[index]

        if result == "<end>":
            break
        starting_sequence.append(result)
    return prediction_output

def create_midi(prediction_output, step_duration=0.25, filepath='output.mid'):
    """
    Generates a MIDI file in the file path from a list of notes

    Args:
        prediction_output (list): _description_
        filepath (str, optional): _description_. Defaults to 'output.mid'.
    """
    midi_stream = stream.Stream()
    step_counter = 1
    current_note_or_chord = None

    # create note and chord objects based on the values generated by the model
    for i, pattern in enumerate(prediction_output):
        # pattern is a chord
        try:
            if pattern != "_" or i+1 == len(prediction_output):
                if current_note_or_chord:
                    quarter_length = step_duration * step_counter
                    if current_note_or_chord == "r":
                        to_add = note.Rest(quarterLength=quarter_length)
                    elif ("." in current_note_or_chord):
                        notes_in_chord = current_note_or_chord.split('.')
                        notes = []
                        for current_note in notes_in_chord:
                            new_note = note.Note(int(current_note))
                            new_note.storedInstrument = instrument.Piano()
                            notes.append(new_note)
                        to_add = chord.Chord(notes, quarterLength=quarter_length)
                    else:
                        to_add = note.Note(int(current_note_or_chord), quarterLength=quarter_length)
                        to_add.storedInstrument = instrument.Piano()
                    print(quarter_length, to_add)
                    midi_stream.append(to_add)
                    step_counter = 1

                current_note_or_chord = pattern
            else:
                step_counter += 1

        except Exception as e:
            print(f"Error processing {pattern}: {e}")
    midi_stream.write('midi', fp=filepath)


if __name__ == "__main__":
    seed = ["60.64.65", "_", "_", "_", "93", "_", "_", "_", "89", "_",
            "86", "_", "_", "_", "41.48.53", "_", "78", "_", "100", "_",
            "62", "_", "63", "_", "57", "_", "_", "_", "57", "_",
            "62.74", "_", "_", "_", "93", "_", "_", "_", "89", "_",
            "88.84", "_", "_", "_", "78", "_", "_", "_", "89", "_",]
    predicted_notes = predict_notes(seed, 50, temperature=0.8, n_notes=300)
    create_midi(predicted_notes)


